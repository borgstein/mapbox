<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Display HTML clusters with custom properties</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; }

.marker {
    cursor: pointer;
    border: none;
}

/* en masse STYLING */
/* Styling for the banner/header section */
.popup-header {
  background-color: #007bff;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 18px;
  font-weight: bold;
  padding: 10px;
  margin-bottom: 10px;
}

/* Styling for the popup container */
.mapboxgl-popup {
  max-width: 300px;
  border-radius: 8px;
  box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);
  font-family: Arial, sans-serif;
}

/* Styling for the popup content */
.mapboxgl-popup-content {
  padding: 10px;
}

/* Styling for the popup text */
.mapboxgl-popup-content div {
  margin-bottom: 8px;
}

/* Styling for the individual-points popups */
.individual-popup {
  max-width: 300px;
  border-radius: 8px;
  box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);
  font-family: Arial, sans-serif;
  padding: 10px;
}

/* Styling for the individual-points popup text */
.individual-popup div {
  margin-bottom: 8px;
}

/* Styling for the individual-points popup banner/header */
.individual-popup-header {
  font-family: Arial, sans-serif;
  font-size: 18px;
  font-weight: bold;
  padding: 10px;
  margin-bottom: 10px;
}

</style>
</head>
<body>y
<div id="map"></div>

<script>

mapboxgl.accessToken = 'pk.eyJ1IjoiYm9yZ3N0ZWluIiwiYSI6ImNrbWZmMGdsZzM0b3QybnAxYzgyeXl0aW0ifQ.TidgWkf_hwXD2CccezoLLw';
var map = new mapboxgl.Map({
    container: 'map', 
    style: 'mapbox://styles/borgstein/clhiy9pq901ii01pg2m9xc24y',
    center: [-1.3, 51.77], 
    zoom: 12.5 
});

//----------------VARIABLES----------------------------------
// Mapping of BMI values to colors
const biodiversityColors = {
  'Vascular plants': '#008000',
  'Mammals': '#FF0000',
  'Insects': '#FFFF00',
  'Birds': '#00FFFF',
  'Arachnids': '#800080',
  'Non-Vascular plants': '#00FF00',
  'Molluscs': '#0000FF',
  'Annelids': '#FFA500',
  'Crustaceans': '#000080',
  'Fungi': '#FF00FF',
  'Amphibians': '#800000',
  'Myriapods': '#808080',
  'Entognatha': '#008080',
  'Nematodes': '#800080',
  'Lichen': '#808080',
  'Reptiles': '#FF4500'
};

//global page variables
let totalPages = 0; // Store the total number of pages globally


//pop instance
const popup = new mapboxgl.Popup({
  closeButton: true,
  closeOnClick: false
});

//------------------FILTERS------------
var filterOptions = {
  BMI: [],
  RT: [],
  'University of Oxford Estate Area(s)': [],
  'University of Oxford Estate Area(s) Specific': [],
  Habitat: [],
  'Study Season(s) (If Applicable)': [],
  'Type of Biodiversity Measurement': [],
  'Time Series Data Set (2+)': [],
  'Soil organic carbon': []
};

///----------------LOAD MAP BITS-----------------------------
map.on('load', function () {
    map.addSource('estates', {
        type: 'geojson',
        data: 'estates_map.json',
        cluster: true,
        clusterMaxZoom: 16, 
        clusterRadius: 10 
    });

    map.addLayer({
    id: 'clusters',
    type: 'circle',
    source: 'estates',
    filter: ['has', 'point_count']
});
    map.addLayer({
    id: 'individual-points',
    type: 'circle',
    source: 'estates',
    filter: ['!', ['has', 'point_count']],
    paint: {
        'circle-color': [
            'match',
            ['get', 'BMI'],
            'Vascular plants', '#008000',
            'Mammals', '#FF0000',
            'Insects', '#FFFF00',
            'Birds', '#00FFFF',
            'Arachnids', '#800080',
            'Non-Vascular plants', '#00FF00',
            'Molluscs', '#0000FF',
            'Annelids', '#FFA500',
            'Crustaceans', '#000080',
            'Fungi', '#FF00FF',
            'Amphibians', '#800000',
            'Myriapods', '#808080',
            'Entognatha', '#008080',
            'Nematodes', '#800080',
            'Lichen', '#808080',
            'Reptiles', '#FF4500',
            '#000000' // default color if the BMI is not listed
        ],
        'circle-radius': 12
    }
    });

    map.on('data', function(e) {
    if (e.dataType === 'source' && e.sourceId === 'estates') {
        // Remove existing custom markers
        if (typeof map.customMarkers !== 'undefined') {
            for (let marker of map.customMarkers) {
                marker.remove();
            }
        }

        map.customMarkers = [];

        // Get all clusters
        const features = map.querySourceFeatures('estates', { sourceLayer: 'clusters' });
        
        for (let feature of features) {
            if (!feature.properties.cluster) continue;

            // Get data for the cluster
            const clusterId = feature.properties.cluster_id;
            const pointCount = feature.properties.point_count;
            const clusterSource = map.getSource('estates');
            clusterSource.getClusterLeaves(clusterId, pointCount, 0, function(err, leaves) {
                if (err) {
                    console.error('Error while getting cluster leaves:', err);
                    return;
                }

                // Count categories in the cluster
                let categoryCounts = {};
                for (let leaf of leaves) {
                    let category = leaf.properties['BMI'];
                    if (categoryCounts[category]) {
                        categoryCounts[category]++;
                    } else {
                        categoryCounts[category] = 1;
                    }
                }

                // Prepare canvas for the donut chart
                let canvas = document.createElement('canvas');
                canvas.width = 50; // adjust size to your needs
                canvas.height = 50; // adjust size to your needs
                let ctx = canvas.getContext('2d');

                // Draw the donut chart
                drawDonutChart(ctx, categoryCounts, pointCount);

                // Create a custom HTML marker using the canvas
                let el = document.createElement('div');
                el.className = 'marker';
                el.style.width = `${ctx.canvas.width}px`;
                el.style.height = `${ctx.canvas.height}px`;
                el.appendChild(canvas);

                // Add the marker to the map
                let coords = leaves[0].geometry.coordinates; // coordinates of the first point in the cluster
                let marker = new mapboxgl.Marker(el)
                    .setLngLat(coords)
                    .addTo(map);

                // Keep track of the marker to remove it later
                map.customMarkers.push(marker);
            });
        }
    }
});
//Individual-points popup
map.on('click', 'individual-points', function (e) {
  var coordinates = e.features[0].geometry.coordinates.slice();
  var properties = e.features[0].properties;

  // Ensure that if the map is zoomed out such that multiple
  // copies of the feature are visible, the popup appears
  // over the copy being pointed to.
  while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
    coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
  }

  var color = getColorByBMI(properties.BMI);
  var content = buildIndividualFeatureContent(properties, color);

  activePopup = new mapboxgl.Popup()
    .setLngLat(coordinates)
    .setHTML(content)
    .addTo(map);
});
    
});

    map.on('mouseenter', 'individual-points', function () {
    map.getCanvas().style.cursor = 'pointer';
    });

    map.on('mouseleave', 'individual-points', function () {
    map.getCanvas().style.cursor = '';
    });

    map.on('mousemove', 'clusters', function(e) {
    var properties = e.features[0].properties;
    });

//-----CLUSTER POPUPS
map.on('click', 'clusters', function (e) {
  const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
  if (features.length === 0) return;

  const clusterId = features[0].properties.cluster_id;
  const pointCount = features[0].properties.point_count;
  const clusterSource = map.getSource('estates');

  clusterSource.getClusterLeaves(clusterId, pointCount, 0, function (err, leaves) {
    if (err) {
      console.error('Error while getting cluster leaves:', err);
      return;
    }

    const sortedLeaves = leaves.sort((a, b) => a.properties.UID.localeCompare(b.properties.UID));

    // Open the popup
    activePopup = showPopup(sortedLeaves, 0, e.lngLat);
  });
});

//Move the sortedLeaves and popupContent variables outside the click event listener so they can be accessed by the pagination event listeners:
let sortedLeaves = []; // Store the sorted leaves globally
let popupContent = ''; // Store the popup content globally

//CLUSTER POPUP EVENT LISTENERS
popup.on('open', function () {
  document.getElementById('popup-prev').addEventListener('click', function () {
    currentPage = Math.max(1, currentPage - 1);
    updatePopupContent();
  });

  document.getElementById('popup-next').addEventListener('click', function () {
    currentPage = Math.min(totalPages, currentPage + 1);
    updatePopupContent();
  });
});


/////////////////////////////////////FUNCTIONS/////////////////////////////
function drawDonutChart(ctx, categoryCounts, pointCount) {
    const canvasSize = Math.max(50, pointCount); // Adjust the size based on point_count
    ctx.canvas.width = canvasSize;
    ctx.canvas.height = canvasSize;

    const cx = ctx.canvas.width / 2;
    const cy = ctx.canvas.height / 2;
    const radius = Math.min(cx, cy) * 0.8;
    const total = Object.values(categoryCounts).reduce((a, b) => a + b, 0);
    let startAngle = -Math.PI / 2;

    // Get category keys and colors
    let keys = Object.keys(categoryCounts);
    let colors = {
        'Vascular plants': '#008000',
        'Mammals': '#FF0000',
        'Insects': '#FFFF00',
        'Birds': '#00FFFF',
        'Arachnids': '#800080',
        'Non-Vascular plants': '#00FF00',
        'Molluscs': '#0000FF',
        'Annelids': '#FFA500',
        'Crustaceans': '#000080',
        'Fungi': '#FF00FF',
        'Amphibians': '#800000',
        'Myriapods': '#808080',
        'Entognatha': '#008080',
        'Nematodes': '#800080',
        'Lichen': '#808080',
        'Reptiles': '#FF4500'
    };

    // Draw arcs
    for (let i = 0; i < keys.length; i++) {
        const proportion = categoryCounts[keys[i]] / total;
        const endAngle = startAngle + proportion * 2 * Math.PI;

        ctx.beginPath();
        ctx.arc(cx, cy, radius, startAngle, endAngle);
        ctx.lineTo(cx, cy);
        ctx.fillStyle = colors[keys[i]];
        ctx.fill();

        startAngle = endAngle;
    }

    // Draw inner circle
    ctx.beginPath();
    ctx.arc(cx, cy, radius * 0.6, 0, 2 * Math.PI);
    ctx.fillStyle = '#ffffff';
    ctx.fill();

    // Add text in the middle
    ctx.fillStyle = '#000000';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(pointCount, cx, cy);
}

//Implement the getPopupContent function to generate the paginated content for the popup.
function getPopupContent(leaves) {
  const pageSize = 1; // Number of features to display per page
  sortedLeaves = leaves.sort((a, b) => a.properties.UID.localeCompare(b.properties.UID));
  const numLeaves = sortedLeaves.length;
  totalPages = Math.ceil(numLeaves / pageSize);
  popupContent = ''; // Reset the popup content

  // Generate the HTML content for each feature
  for (let i = 0; i < sortedLeaves.length; i++) {
    const feature = sortedLeaves[i];
    popupContent += buildFeatureContent(feature);
  }

  // Add pagination controls if there are more than one page
  if (totalPages > 1) {
    popupContent += buildPaginationControls();
  }

  return popupContent;
}
// feature to build indiidual point popup
function buildIndividualFeatureContent(properties, color) {
  // Extract the desired properties
  const { UID, Title, authorCreator, BMI, RT } = properties;

  // Build the HTML content for the feature
  let content = `<div class="individual-popup">`;
  content += `<div class="individual-popup-header" style="background-color: ${color}; color: ${isBannerColorLight(color) ? 'black' : 'white'};">${Title}</div>`;
  content += `<div><strong>UID:</strong> ${UID}</div>`;
  content += `<div><strong>Author/Creator:</strong> ${authorCreator}</div>`;
  content += `<div><strong>Indicator:</strong> ${BMI}</div>`;
  content += `<div><strong>Reference Type:</strong> ${RT}</div>`;
  content += `</div>`;

  return content;
}

//Implement the buildFeatureContent function to generate the HTML content 
function buildFeatureContent(feature, pageIndex, totalPages) {
  // Extract the desired properties from the feature
  const { UID, Title, authorCreator, BMI, RT } = feature.properties;

  // Build the HTML content for the feature
  const bannerColor = getColorByBMI(BMI);
  const textColor = isBannerColorLight(bannerColor) ? 'black' : 'white';

  let content = `<div class="popup-header" style="background-color: ${bannerColor}; color: ${textColor};">${Title}</div>`;
  content += `<div><strong>UID:</strong> ${UID}</div>`;
  content += `<div><strong>Author/Creator:</strong> ${authorCreator}</div>`;
  content += `<div><strong>Indicator:</strong> ${BMI}</div>`;
  content += `<div><strong>Reference Type:</strong> ${RT}</div>`;
  content += '<hr>'; // Add a horizontal line between features

  // Build the pagination controls and concatenate them to the content
  const paginationControls = buildPaginationControls(pageIndex, totalPages);
  content += paginationControls;

  return content;
}

function getColorByBMI(BMI) {
  // Define the colors based on BMI values
  const colors = {
    'Vascular plants': '#008000',
    'Mammals': '#FF0000',
    'Insects': '#FFFF00',
    'Birds': '#00FFFF',
    'Arachnids': '#800080',
    'Non-Vascular plants': '#00FF00',
    'Molluscs': '#0000FF',
    'Annelids': '#FFA500',
    'Crustaceans': '#000080',
    'Fungi': '#FF00FF',
    'Amphibians': '#800000',
    'Myriapods': '#808080',
    'Entognatha': '#008080',
    'Nematodes': '#800080',
    'Lichen': '#808080',
    'Reptiles': '#FF4500'
  };

  return colors[BMI];
}

function isBannerColorLight(color) {
  // Convert the color to RGB format
  const rgbColor = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
  const r = parseInt(rgbColor[1], 16);
  const g = parseInt(rgbColor[2], 16);
  const b = parseInt(rgbColor[3], 16);

  // Calculate the brightness of the color
  const brightness = (r * 299 + g * 587 + b * 114) / 1000;

  // Return true if the brightness is above a threshold (adjust as needed)
  return brightness > 128;
}

//Implement the buildPaginationControls function to generate the HTML for the pagination controls within the popup
function buildPaginationControls(currentPage, totalPages) {
  const prevButton = `<button id="popup-prev">Previous</button>`;
  const nextButton = `<button id="popup-next">Next</button>`;
  const pageText = `<span>${currentPage}/${totalPages}</span>`;


  return `<div>${prevButton}${pageText}${nextButton}</div>`;
}

function updatePopupContent() {
  const startIndex = (currentPage - 1) * pageSize;
  const endIndex = Math.min(startIndex + pageSize, sortedLeaves.length);
  let content = '';

  for (let i = startIndex; i < endIndex; i++) {
    const feature = sortedLeaves[i];
    content += buildFeatureContent(feature);
  }

  if (totalPages > 1) {
    content += buildPaginationControls();
  }

  popup.setHTML(content);
}

//SHOW POPUP FUNCTION 
function showPopup(leaves, pageIndex, lngLat) {
  const feature = leaves[pageIndex];
  const popupContent = buildFeatureContent(feature, pageIndex + 1, leaves.length);

  // Create a temporary hidden div to hold the popup content
  const tempContainer = document.createElement('div');
  tempContainer.innerHTML = popupContent;

  // Find the pagination controls within the temporary container
  const prevButton = tempContainer.querySelector('#popup-prev');
  const nextButton = tempContainer.querySelector('#popup-next');

  // Update the popup content with the modified HTML
  popup.setLngLat(lngLat)
    .setDOMContent(tempContainer)
    .addTo(map);

  // Add event listeners to the pagination controls
  prevButton.addEventListener('click', function () {
    const prevIndex = (pageIndex - 1 + leaves.length) % leaves.length;
    showPopup(leaves, prevIndex, lngLat);
  });

  nextButton.addEventListener('click', function () {
    const nextIndex = (pageIndex + 1) % leaves.length;
    showPopup(leaves, nextIndex, lngLat);
  });
}

//FILTERS FILTERS FILTERS FILTERS FILTERS

</script>

</body>
</html>